/* Copyright (C) 2020 by NavInfo Europe B.V. The Netherlands - All rights reserved
 * Information classification: Confidential
 * This content is protected by international copyright laws.
 * Reproduction and distribution is prohibited without written permission. */
#include <vector>

#include <gtest/gtest.h>

#include <nie/core/time.hpp>

// NOTE: Using namespace is local to this test
using namespace std::chrono;
using namespace std::literals::chrono_literals;

class Time : public ::testing::Test {
protected:
    // Use a shorter notation
    using ZonedUTC = nie::UTCDateTimeTz<seconds>;

    struct TestCase {
        nie::GPSWeekTime<seconds> gps_week_time;
        nie::GPSDayTime<seconds> gps_day_time;
        ZonedUTC utc_date_time_tz;
    };

    // For real datasets, GPS week number and GPS time-in-week are taken from a recorded .sta file, GPS time-in-day is
    // taken from the post-processed .Cam file (which is generated by a standard inertial explorer export profile), the
    // UTC date is extracted from the filename of the .Cam file, and the timezone offset is always CST (UTC+08:00).
    // Fractional seconds are ignored, after checking they were equal (except for rounding), since they never affect
    // conversion between UTC / GPS clocks. The rest of the data is created by hand.
    // clang-format off
    std::vector<TestCase> const kTestCases
    {
        // Basic test cases
        { {weeks{   0},      1s}, {days{    0},     1s}, ZonedUTC(1980_y/01/06,     1s) },  // GPS epoch +1s
        { {weeks{   0},   3599s}, {days{    0},  3599s}, ZonedUTC(1980_y/01/06,  3599s) },  // GPS epoch +1h -1s
        { {weeks{   0},   3600s}, {days{    0},  3600s}, ZonedUTC(1980_y/01/06,  3600s) },  // GPS epoch +1h
        { {weeks{   0},  86399s}, {days{    0}, 86399s}, ZonedUTC(1980_y/01/06, 86399s) },  // GPS epoch +1d -1s
        { {weeks{   0},  86400s}, {days{    1},     0s}, ZonedUTC(1980_y/01/07,     0s) },  // GPS epoch +1d
        { {weeks{   0}, 604799s}, {days{    6}, 86399s}, ZonedUTC(1980_y/01/12, 86399s) },  // GPS epoch +1w -1s
        { {weeks{   1},      0s}, {days{    7},     0s}, ZonedUTC(1980_y/01/13,     0s) },  // GPS epoch +1w

        // Timezone offset (Positive / Negative) -- Add 1 day to avoid creating a time before the GPS epoch
        { {weeks{   0},  86399s}, {days{    0}, 86399s}, ZonedUTC(1980_y/01/07,  3599s, -1h) },  // GPS epoch -01:00 +1d +1h -1s
        { {weeks{   0},  86400s}, {days{    1},     0s}, ZonedUTC(1980_y/01/07,  3600s, -1h) },  // GPS epoch -01:00 +1d +1h
        { {weeks{   0},  86399s}, {days{    0}, 86399s}, ZonedUTC(1980_y/01/06, 82799s, +1h) },  // GPS epoch +01:00 +1d -1h -1s
        { {weeks{   0},  86400s}, {days{    1},     0s}, ZonedUTC(1980_y/01/06, 82800s, +1h) },  // GPS epoch +01:00 +1d -1h

        // First leap second introduced after GPS epoch
        { {weeks{  77}, 259199s}, {days{  541}, 86399s}, ZonedUTC(1981_y/06/30, 86399s, +0h, false) },  // 1st leap second -1s
        { {weeks{  77}, 259200s}, {days{  542},     0s}, ZonedUTC(1981_y/06/30, 86399s, +0h, true ) },  // 1st leap second
        { {weeks{  77}, 259201s}, {days{  542},     1s}, ZonedUTC(1981_y/07/01,     0s, +0h, false) },  // 1st leap second +1s
        { {weeks{  77}, 345601s}, {days{  543},     1s}, ZonedUTC(1981_y/07/02,     0s, +0h, false) },  // 1st leap second +1d

        // First leap second introduced after GPS epoch + Timezone offset (Positive / Negative)
        { {weeks{  77}, 259199s}, {days{  541}, 86399s}, ZonedUTC(1981_y/07/01,  3599s, -1h, false) },  // 1st leap second -01:00 -1s
        { {weeks{  77}, 259200s}, {days{  542},     0s}, ZonedUTC(1981_y/07/01,  3599s, -1h, true ) },  // 1st leap second -01:00
        { {weeks{  77}, 259201s}, {days{  542},     1s}, ZonedUTC(1981_y/07/01,  3600s, -1h, false) },  // 1st leap second -01:00 +1s
        { {weeks{  77}, 259199s}, {days{  541}, 86399s}, ZonedUTC(1981_y/06/30, 82799s, +1h, false) },  // 1st leap second +01:00 -1s
        { {weeks{  77}, 259200s}, {days{  542},     0s}, ZonedUTC(1981_y/06/30, 82799s, +1h, true ) },  // 1st leap second +01:00
        { {weeks{  77}, 259201s}, {days{  542},     1s}, ZonedUTC(1981_y/06/30, 82800s, +1h, false) },  // 1st leap second +01:00 +1s

        // Data directory "/data/aiim/HAD_project_Jan2019/A81/Pre-processData/..."
        { {weeks{2034}, 376926s}, {days{14242}, 31326s}, ZonedUTC(2019_y/01/03,  2508s, +8h) },  // 0000-1-006-190103
        { {weeks{2034}, 462661s}, {days{14243}, 30661s}, ZonedUTC(2019_y/01/04,  1843s, +8h) },  // 0000-1-006-190104
        { {weeks{2035}, 116205s}, {days{14246}, 29805s}, ZonedUTC(2019_y/01/07,   987s, +8h) },  // 0000-1-006-190107

        // Data directory "/data/aiim/HAD_project_Jan2019/Eindhoven/..."
        { {weeks{2034}, 133156s}, {days{14239}, 46756s}, ZonedUTC(2018_y/12/31, 17938s, +8h) },  // 0000-1-406-181231
        { {weeks{2035}, 381851s}, {days{14249}, 36251s}, ZonedUTC(2019_y/01/10,  7433s, +8h) },  // 0000-1-006-190110
        { {weeks{2035}, 393620s}, {days{14249}, 48020s}, ZonedUTC(2019_y/01/10, 19202s, +8h) },  // 0000-1-106-190110
        { {weeks{2035}, 465620s}, {days{14250}, 33620s}, ZonedUTC(2019_y/01/11,  4802s, +8h) },  // 0000-1-006-190111

        // Data directory "/data/aiim/AIIM_Drives/20190519/..."
        { {weeks{2054},  38664s}, {days{14378}, 38664s}, ZonedUTC(2019_y/05/19,  9846s, +8h) }   // 0000-1-006-190519
    };
    // clang-format on
};

TEST_F(Time, Representation) {
    // Obtain current time
    nie::Timestamp_ns const t1 = nie::Timestamp_ns::clock::now();

    // Add one nano second
    nie::Timestamp_ns const t2 = t1 + nanoseconds(1);

    // Ensure that we have nanosecond accuracy (No rounding occurs)
    EXPECT_NE(t1, t2);
}

TEST_F(Time, GPSTimeAlternativeRepresentations) {
    // Loop over all test cases
    for (auto const& test_case : kTestCases) {
        // Obtain GPS week/time and GPS day/time from test case
        auto const gps_week_time = test_case.gps_week_time;
        auto const gps_day_time = test_case.gps_day_time;
        auto const utc_date_time_tz = test_case.utc_date_time_tz;

        // Convert to time point in their respective clocks
        auto const gps_time_from_week_time = nie::ToGPSTime(gps_week_time);
        auto const gps_time_from_day_time = nie::ToGPSTime(gps_day_time);
        auto const gps_time_from_utc_zoned = nie::ToGPSTime(utc_date_time_tz);

        // Check that all represent the same time point
        EXPECT_EQ(gps_time_from_week_time, gps_time_from_day_time);
        EXPECT_EQ(gps_time_from_week_time, gps_time_from_utc_zoned);

        // Compare conversion back to GPS Week/Time
        EXPECT_EQ(gps_week_time, nie::ToGPSWeekTime(gps_time_from_week_time));

        // Compare conversion back to GPS Date/Time
        EXPECT_EQ(gps_day_time, nie::ToGPSDayTime(gps_time_from_day_time));
    }
}

// Assume that UTC clock and GPS clock are synced (In reality they are not)
TEST_F(Time, TZUTCDateGPSTime) {
    // Loop over all test cases
    for (auto const& test_case : kTestCases) {
        // Convert UTC date, UTC timezone offset, and GPS time-in-day to a proper GPS time
        auto const gps_time = nie::ToGPSTime(
            test_case.utc_date_time_tz.date(),
            test_case.utc_date_time_tz.tz_offset(),
            test_case.utc_date_time_tz.leap_second(),
            test_case.gps_day_time.time_in_day);

        // Determine GPS Week / time representation
        auto const gps_week_time = nie::ToGPSWeekTime(gps_time);

        EXPECT_EQ(gps_week_time.week, test_case.gps_week_time.week);
        EXPECT_EQ(gps_week_time.time_in_week, test_case.gps_week_time.time_in_week);
    }
}

TEST_F(Time, DoubleToDuration) {
    double secs = 14969.540;
    std::chrono::nanoseconds ns{static_cast<std::chrono::nanoseconds::rep>(secs * 1e9)};
    EXPECT_EQ(ns, nie::RepresentDoubleAsDuration<std::chrono::nanoseconds>(secs));
}