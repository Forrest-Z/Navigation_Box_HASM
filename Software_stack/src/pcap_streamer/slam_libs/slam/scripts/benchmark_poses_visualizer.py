#!/usr/bin/python3
# Copyright (C) 2020 by NavInfo Europe B.V. The Netherlands - All rights reserved
# Information classification: Confidential
# This content is protected by international copyright laws.
# Reproduction and distribution is prohibited without written permission.

""" Pose Benchmarking Visualizer

This script can be used to visualize the results of the pose_benchmarker C++ application.

The input will be the *_pose_difference.csv file generated by the C++ app.
This file will be used to generate two plots, one for the absolute and one for the relative pose errors.
It will also output the found metrics to the console.

The plots can be used to determine how well both .pose files match, and if there are any issues that have to be resolved.

Besides being used in the benchmark_poses_pipeline, it can also be used as a standalone application:
Example:
    Either using python:
        $ python benchmark_poses_visualizer.py [ARGUMENTS]

    Or if set as executable (using chmod +x ./benchmark_poses_visualizer.py):
        $ ./benchmark_poses_visualizer.py [ARGUMENTS]

Required Arguments:             Type    Purpose
    --in_file_csv               [PATH]  Path to the input pose difference .csv file.
    
Note:
    * Requires matplotlib to be installed
    * The yaw plots and printed values will be the same for both relative and absolute
"""

import argparse
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
import matplotlib.transforms as transforms
import numpy as np
import os

from nie_utils import arg_checks


def confidence_ellipse(x, y, ax, n_std=3.0, facecolor='none', **kwargs):
    """
    https://matplotlib.org/devdocs/gallery/statistics/confidence_ellipse.html
    Create a plot of the covariance confidence ellipse of *x* and *y*.

    Parameters
    ----------
    x, y : array-like, shape (n, )
        Input data.

    ax : matplotlib.axes.Axes
        The axes object to draw the ellipse into.

    n_std : float
        The number of standard deviations to determine the ellipse's radiuses.

    **kwargs
        Forwarded to `~matplotlib.patches.Ellipse`

    Returns
    -------
    matplotlib.patches.Ellipse
    """
    if x.size != y.size:
        raise ValueError("x and y must be the same size")

    cov = np.cov(x, y)
    pearson = cov[0, 1] / np.sqrt(cov[0, 0] * cov[1, 1])
    # Using a special case to obtain the eigenvalues of this
    # two-dimensionl dataset.
    ell_radius_x = np.sqrt(1 + pearson)
    ell_radius_y = np.sqrt(1 - pearson)
    ellipse = Ellipse((0, 0), width=ell_radius_x * 2, height=ell_radius_y * 2,
                      facecolor=facecolor, **kwargs)

    # Calculating the stdandard deviation of x from
    # the squareroot of the variance and multiplying
    # with the given number of standard deviations.
    std_x = np.sqrt(cov[0, 0])
    scale_x = std_x * n_std
    mean_x = np.mean(x)

    # calculating the stdandard deviation of y ...
    std_y = np.sqrt(cov[1, 1])
    scale_y = std_y * n_std
    mean_y = np.mean(y)

    transf = transforms.Affine2D() \
        .rotate_deg(45) \
        .scale(scale_x, scale_y) \
        .translate(mean_x, mean_y)

    ellipse.set_transform(transf + ax.transData)
    return ax.add_patch(ellipse)


def hist_with_std_regions(ax, title, mean, std, fig_color, data_range, data):
    """
    Creates a subplot with standard deviation regions.

    These regions indicate where 68% and 95% of all points will fall assuming pure gaussian noise.
    For this, the mean and std given are used.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
        The axes object to draw the histogram into.

    title : string
        Title of the new figure

    mean : float
        Mean value for the input data

    std : float
        Standard deviation for the input data

    fig_color : string
        Figure color string. E.g. 'C1' or 'tab:gray'

    data_range : list
        List containing both the min and max limit for the plot

    data : numpy array, shape (n, 1)
        Input data from which to build the histogram
    """

    ax.grid(linestyle='-')
    ax.title.set_text(title)
    ax.set_ylabel("Percentage [%]")
    # Creating the regions
    ax.axvspan(mean - std, mean + std, color=fig_color, alpha=0.2)
    ax.axvspan(mean - 2 * std, mean + 2 * std, color=fig_color, alpha=0.2)
    # Weights are required to make the area of the histogram count up to 1.0
    weights = np.ones_like(data) / float(len(data)) * 100.0
    ax.hist(
        data,
        range=data_range,
        color=fig_color,
        weights=weights,
        density=False,
        bins=50)


def benchmark_figure(figure_name, x, y, yaw):
    """
    Creates a new figure to display the benchmarking results for the given data.

    This allows creating multiple figures for different interpretations of the input data.

    It also outputs the found mean/std/95% error bound values to console.

    Parameters
    ----------
    figure_name : string
        The name of the new figure.

    x : numpy array, shape (n, 1)
        Input delta x data

    y : numpy array, shape (n, 1)
        Input delta y data

    yaw : numpy array, shape (n, 1)
        Input delta yaw data
    """

    bm_fig = plt.figure(figure_name, figsize=(19.20, 10.80), dpi=100.0)
    n_values = x.size
    dt = np.linspace(0, n_values / 10.0, n_values)

    # Get and print stats
    dist = np.sqrt(np.square(x) + np.square(y))
    # Mean error
    mean_x = np.mean(x)
    mean_y = np.mean(y)
    mean_yaw = np.mean(yaw)
    mean_dist = np.mean(dist)
    # Standard Deviation (68% falls in)
    std_x = np.std(x)
    std_y = np.std(y)
    std_yaw = np.std(yaw)
    std_dist = np.std(dist)
    # Assuming 68-95-99.7% rule
    print("Min/max x: \t\t[", min(x), ",", max(x), "]")
    print("Min/max y: \t\t[", min(y), ",", max(y), "]")
    print("Min/max yaw: \t\t[", min(yaw), ",", max(yaw), "]")
    print("Mean x error: \t\t", mean_x)
    print("Mean y error: \t\t", mean_y)
    print("Mean absolute error \t", mean_dist)
    print("Mean yaw error: \t", mean_yaw)
    print("Stddev x: \t\t", std_x)
    print("Stddev y: \t\t", std_y)
    print("Stddev yaw: \t\t", std_yaw)
    # Assuming 68-95-99.7% rule
    print("95% error bound x: \t", 2 * std_x)
    print("95% error bound y: \t", 2 * std_y)
    print("95% error bound yaw: \t", 2 * std_yaw)

    # Create plots:
    # Metric 3: ellipse containing 95% of errors
    # Initialize figure
    ax_ce = plt.subplot(221)
    ax_ce.axis('equal')
    ax_ce.axvline(c='grey', lw=1)
    ax_ce.axhline(c='grey', lw=1)
    ax_ce.grid(linestyle='-')
    ax_ce.title.set_text("x/y position errors with 95% confidence range")
    ax_ce.set_xlabel("Position x error [m]")
    ax_ce.set_ylabel("Position y error [m]")
    # Draw x/y error points
    ax_ce.scatter(x, y, s=0.3)
    # Draw confidence ellipse for standard deviation 2
    # Emperical rule: 68-95-99.7 (std dev 1-2-3)
    confidence_ellipse(x, y, ax_ce, n_std=2.0, edgecolor='red')

    # Plot x/y over (fictional) time
    ax_dt = plt.subplot(422)
    # Draw horizontal lines indicating the 65% range/precision
    ax_dt.axhspan(mean_x - std_x, mean_x + std_x, color='C1', alpha=0.2)
    ax_dt.axhspan(mean_y - std_y, mean_y + std_y, color='C2', alpha=0.2)
    # Plot x/y themselves
    lx, = ax_dt.plot(dt, x, 'C1')
    ly, = ax_dt.plot(dt, y, 'C2')
    ax_dt.grid(linestyle='-')
    ax_dt.title.set_text("x/y errors over time")
    ax_dt.set_ylabel("Position x/y error [m]")
    ax_dt.legend([lx, ly], ['x error', 'y_error'])
    # Plot heading over (fictional) time
    ax_heading = plt.subplot(424)
    ax_heading.axhspan(
        mean_yaw - std_yaw,
        mean_yaw + std_yaw,
        color='C3',
        alpha=0.2)
    ax_heading.plot(dt, yaw, color='C3')
    ax_heading.grid(linestyle='-')
    ax_heading.title.set_text("Heading error over time")
    ax_heading.set_ylabel("Heading error [deg]")

    # Metric 4: histogram with the distribution over 1-D error magnitudes
    # Set range on 99.7% of all values, assuming noise around 0
    # We want to have both x and y with the same x axis for clarity
    std_xy_max = max(std_x,std_y)
    xy_range = [-std_xy_max*3, std_xy_max*3]
    dist_range = [0, std_dist*3]
    yaw_range = [-std_yaw*3, std_yaw*3]
    # x/y/yaw error histograms
    hist_with_std_regions(
        plt.subplot(425),
        "Position x error histogram [m]",
        mean_x,
        std_x,
        'C1',
        xy_range,
        x)
    hist_with_std_regions(
        plt.subplot(427),
        "Position y error histogram [m]",
        mean_y,
        std_y,
        'C2',
        xy_range,
        y)
    hist_with_std_regions(
        plt.subplot(428),
        "Heading angle error histogram [deg]",
        mean_yaw,
        std_yaw,
        'C3',
        yaw_range,
        yaw)
    # Euclidian distance for x/y error histogram
    ax_dist = plt.subplot(426)
    ax_dist.title.set_text("Absolute position error histogram [m]")
    ax_dist.set_ylabel("Percentage [%]")
    ax_dist.grid(linestyle='-')
    dist_weights = np.ones_like(dist) / float(len(dist)) * 100.0
    ax_dist.hist(
        dist,
        range=dist_range,
        weights=dist_weights,
        density=False,
        bins=50)

    # Fix spacing at full screen
    bm_fig.subplots_adjust(
        hspace=0.3,
        wspace=0.15,
        left=0.05,
        right=0.98,
        top=0.95,
        bottom=0.05)


def visualize_benchmarking_results(csv_filename):
    """
    Main script that reads the pose delta csv file and generates the plots.

    Parameters
    ----------
    csv_filename : string
        Path to the input csv file
    """
    # Columns are timestamps, dx, dy, dz, droll, dpitch, dyaw
    # We only use dx, dy, dyaw at this point
    csv_data = np.genfromtxt(
        csv_filename,
        delimiter=',',
        skip_header=1,
        usecols=(
            1,  # absolute x
            2,  # absolute y
            4,  # relative x
            5,  # relative y
            9))  # yaw
    # Columns here are in the order of the use_cols, not the input csv
    dx_absolute = csv_data[:, 0]
    dy_absolute = csv_data[:, 1]
    dx_relative = csv_data[:, 2]
    dy_relative = csv_data[:, 3]
    dyaw = csv_data[:, 4]

    # Create figures
    print("=== Plotting results ===")
    print("== Absolute x/y Error")
    benchmark_figure("Absolute x/y Error", dx_absolute, dy_absolute, dyaw)
    print("== Relative x/y Error")
    benchmark_figure("Relative x/y Error", dx_relative, dy_relative, dyaw)

    # Show figures
    plt.show()


def benchmark_poses_visualizer():
    # Define and parse command line parameters
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--in_file_csv",
        type=arg_checks.file_exists,
        help="Path to the input pose difference .csv file.",
        required=True)
    args = parser.parse_args()

    print("=== Reading from differences csv ===")
    visualize_benchmarking_results(csv_filename)


if __name__ == '__main__':
    benchmark_poses_visualizer()
